import pandas as pd
from datetime import datetime, timezone, timedelta
from collections import defaultdict, deque
from twisted.internet import reactor, task, defer
from twisted.internet.defer import inlineCallbacks
import treq
import json
import os
from ctrader_open_api import Client, TcpProtocol, Protobuf
from ctrader_open_api.messages.OpenApiModelMessages_pb2 import ProtoOATrendbarPeriod
from keep_alive import keep_alive
from divergence import DivergenceState, detect_signals

VIETNAM_timezone = timezone(timedelta(hours=7))  # UTC+7 cho Vi·ªát Nam

# ================== CONFIGURATION ==================
TELEGRAM_TOKEN = "8358892572:AAHFNZWXwwd_VIL7veQgdLBjNjI253oLCug"
CHAT_ID = "1676202517"

CTRADER_CLIENT_ID = "16778_at26WTcoFS2NYt1GHQS1gJqaSWorbHZCJKA1X9KRe2z5dZRrMo"
CTRADER_SECRET = "unq1iRL42CtmzTk5MQ9CYdcMfnYmOQSV5Nfu94FEX0ZueystC3"
CTRADER_ACCOUNT_ID = "44322853"
CTRADER_ACCESS_TOKEN = "zVuuTkkAeB_uR0htxndUSRztpBuH6n5h0_2S3K2j6zw"
CTRADER_REFRESH_TOKEN = "vad60eaFw4bMvn8OrPEAuizInEJjK_CHwMc3QJO3LOI"
CTRADER_DEMO_HOST = "demo.ctraderapi.com"
CTRADER_DEMO_PORT = 5035

# File l∆∞u token info (Application Spotware)
TOKEN_FILE = "token_info.json"    # File l∆∞u th√¥ng tin token
TOKEN_REFRESH_MARGIN_MINUTES = 5  # Refresh token 5 ph√∫t tr∆∞·ªõc khi h·∫øt h·∫°n

PAIRS = [
    "XAUUSD", "EURUSD", "EURAUD", "EURCAD", "EURCHF", "EURGBP", "EURNZD",
    "GBPUSD", "GBPAUD", "GBPCAD", "GBPCHF", "GBPNZD", "AUDUSD", "AUDCAD",
    "AUDCHF", "AUDNZD", "CADCHF", "USDCHF", "USDCAD", "NZDUSD", "NZDCAD", "NZDCHF"
]

EMA_FAST = 12
EMA_SLOW = 26
MACD_SIGNAL = 9
SCAN_INTERVAL_SEC = 3
MIN_BARS_BACK = 5000
MIN_LOOKBACK_BARS = 10
MAX_LOOKBACK_BARS = 40
SLOPE_THRESHOLD = 0.7

TIMEFRAME_MAP = {
    "5m": ProtoOATrendbarPeriod.M5,
    "15m": ProtoOATrendbarPeriod.M15,
    "30m": ProtoOATrendbarPeriod.M30,
    "1h": ProtoOATrendbarPeriod.H1,
    "4h": ProtoOATrendbarPeriod.H4,
    "1d": ProtoOATrendbarPeriod.D1,
}
PERIOD_SECONDS = {
    ProtoOATrendbarPeriod.M5: 300,
    ProtoOATrendbarPeriod.M15: 900,
    ProtoOATrendbarPeriod.M30: 1800,
    ProtoOATrendbarPeriod.H1: 3600,
    ProtoOATrendbarPeriod.H4: 14400,
    ProtoOATrendbarPeriod.D1: 86400,
    ProtoOATrendbarPeriod.W1: 604800,
}
PRESETS = {
    "4T": ["5m", "15m", "30m", "1h"],
    "2t": ["5m", "15m"],
    "2T": ["30m", "1h"],
}
market_data = defaultdict(lambda: {
    "closes": deque(maxlen=MIN_BARS_BACK),
    "highs": deque(maxlen=MIN_BARS_BACK),
    "lows": deque(maxlen=MIN_BARS_BACK),
    "hist": deque(maxlen=MIN_BARS_BACK),
    "state": DivergenceState(),
    "last_ts": 0,
    "bar_count": 0,          # ƒê·∫øm t·ªïng s·ªë bar nh·∫≠n ƒë∆∞·ª£c
    "history(-1)_bars": 0,   # ƒê·∫øm bar l·ªãch s·ª≠ (-1)
    "last_history_bars": 0,   # ƒê·∫øm bar l·ªãch s·ª≠ g·∫ßn nh·∫•t
    "first_bar_time": None,  # Th·ªùi gian bar ƒë·∫ßu ti√™n
    "last_bar_time": None,   # Th·ªùi gian bar cu·ªëi c√πng
})
active_timeframes = set()

# TH√äM H√ÄM KI·ªÇM TRA COMPLETED BARS
def check_completed_bar_delays():
    """Ki·ªÉm tra xem c√≥ key n√†o kh√¥ng nh·∫≠n ƒë∆∞·ª£c completed bar m·ªõi nh·∫•t"""
    current_time = datetime.now(VIETNAM_timezone)
    current_minutes = int(current_time.timestamp() / 60)

    print(f"\nüîç Checking completed bars at {current_time.strftime('%H:%M:%S')}")

    missing_bars = []

    for key, data in market_data.items():
        if isinstance(key, tuple) and len(key) == 2:
            symbol, tf = key
            last_bar_time = data.get("last_bar_time", 0)

            if last_bar_time == 0:
                continue

            # L·∫•y period c·ªßa timeframe
            period_seconds = PERIOD_SECONDS.get(TIMEFRAME_MAP.get(tf), 300)
            period_minutes = period_seconds // 60

            # T√≠nh to√°n completed bar m·ªõi nh·∫•t m√† bot SHOULD c√≥
            # V√≠ d·ª•: 17:07, period 5m -> latest completed should be 17:05
            expected_latest = (current_minutes // period_minutes) * period_minutes

            # N·∫øu bot's last bar c≈© h∆°n expected latest completed bar
            if last_bar_time < expected_latest:
                minutes_missing = expected_latest - last_bar_time

                last_bar_str = datetime.fromtimestamp(last_bar_time * 60, VIETNAM_timezone).strftime('%H:%M')
                expected_str = datetime.fromtimestamp(expected_latest * 60, VIETNAM_timezone).strftime('%H:%M')

                missing_bars.append({
                    'key': f"{symbol}/{tf}",
                    'last_received': last_bar_str,
                    'should_have': expected_str,
                    'missing_minutes': minutes_missing
                })

                print(f"‚ùå {symbol}/{tf}: Last={last_bar_str}, Should have={expected_str} ({minutes_missing}m missing)")

    if not missing_bars:
        print("‚úÖ All pairs have update latest completed bars")

    return missing_bars

# ================== BAR COUNTER SYSTEM ==================
bar_stats = defaultdict(lambda: {
    "total_bars": 0,
    "history(-1)_bars": 0,
    "last_history_bars": 0,
    "first_received": None,
    "last_received": None,
    "data_quality": "Unknown"
})

def print_bar_stats():
    """In th·ªëng k√™ s·ªë l∆∞·ª£ng bar nh·∫≠n ƒë∆∞·ª£c theo milestone"""
    if not bar_stats:
        print("üìä Ch∆∞a c√≥ d·ªØ li·ªáu bar n√†o")
        return

    print("\n" + "="*60)
    print("üìä BAR STATISTICS REPORT")
    print("="*60)

    for key, stats in bar_stats.items():
        symbol, tf = key
        total = stats['total_bars']
        progress = f"{total}/{MIN_BARS_BACK}"
        percentage = (total / MIN_BARS_BACK * 100) if total > 0 else 0

        print(f"üîπ {symbol}/{tf}: {progress} ({percentage:.1f}%)")
        print(f"   üìú History(-1): {stats['history(-1)_bars']} | üî¥ Newest_history: {stats['last_history_bars']}")

        # ƒê√°nh gi√° ch·∫•t l∆∞·ª£ng d·ª±a tr√™n t·ª∑ l·ªá ho√†n th√†nh
        if percentage >= 80:
            quality = "‚úÖ Excellent"
        elif percentage >= 50:
            quality = "üü° Good"  
        elif percentage >= 20:
            quality = "üü† Fair"
        else:
            quality = "üî¥ Poor"

        print(f"   üìã Quality: {quality}")

    print("="*60)

def get_bar_summary():
    """T·∫°o summary ng·∫Øn g·ªçn v·ªÅ bar stats"""
    if not bar_stats:
        return "üìä No bar data available"

    total_symbols = len(bar_stats)
    total_bars = sum(stats['total_bars'] for stats in bar_stats.values())
    total_live = sum(stats['last_history_bars'] for stats in bar_stats.values())

    return f"üìä {total_symbols} symbols | {total_bars} total bars | {total_live} live bars"

def reset_bar_stats():
    """Reset t·∫•t c·∫£ th·ªëng k√™ bar"""
    bar_stats.clear()
    for key in market_data.keys():
        market_data[key]["bar_count"] = 0
        market_data[key]["history(-1)_bars"] = 0
        market_data[key]["last_history_bars"] = 0
        market_data[key]["first_bar_time"] = None
        market_data[key]["last_bar_time"] = None
    print("üîÑ ƒê√£ reset t·∫•t c·∫£ bar statistics")

class TokenManager:
    """Qu·∫£n l√Ω Access Token v√† Refresh Token"""

    def __init__(self):
        self.access_token = CTRADER_ACCESS_TOKEN
        self.refresh_token = CTRADER_REFRESH_TOKEN
        self.expires_at = None
        self.refresh_task = None
        self.load_token_info()

    def load_token_info(self):
        """T·∫£i th√¥ng tin token t·ª´ file"""
        try:
            if os.path.exists(TOKEN_FILE):
                with open(TOKEN_FILE, 'r') as f:
                    data = json.load(f)
                    self.access_token = data.get('access_token', CTRADER_ACCESS_TOKEN)
                    self.refresh_token = data.get('refresh_token', CTRADER_REFRESH_TOKEN)
                    expires_str = data.get('expires_at')
                    if expires_str:
                        self.expires_at = datetime.fromisoformat(expires_str.replace('Z', '+00:00'))
                    print(f"‚úÖ ƒê√£ t·∫£i token info t·ª´ {TOKEN_FILE}")
        except Exception as e:
            print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i token info: {e}")

    def save_token_info(self):
        """L∆∞u th√¥ng tin token v√†o file"""
        try:
            data = {
                'access_token': self.access_token,
                'refresh_token': self.refresh_token,
                'expires_at': self.expires_at.isoformat() if self.expires_at else None,
                'updated_at': datetime.now(VIETNAM_timezone).isoformat()
            }
            with open(TOKEN_FILE, 'w') as f:
                json.dump(data, f, indent=2)
            print(f"‚úÖ ƒê√£ l∆∞u token info v√†o {TOKEN_FILE}")
        except Exception as e:
            print(f"‚ùå L·ªói l∆∞u token info: {e}")

    def update_tokens(self, access_token, refresh_token=None, expires_in_seconds=None):
        """C·∫≠p nh·∫≠t token info"""
        self.access_token = access_token
        if refresh_token:
            self.refresh_token = refresh_token

        if expires_in_seconds:
            self.expires_at = datetime.now(VIETNAM_timezone) + timedelta(seconds=expires_in_seconds)
        elif not self.expires_at:
            # M·∫∑c ƒë·ªãnh access token c√≥ h·∫°n 30 ng√†y
            self.expires_at = datetime.now(VIETNAM_timezone) + timedelta(days=30)

        self.save_token_info()
        self.schedule_refresh()

    def should_refresh_token(self):
        """Ki·ªÉm tra c√≥ c·∫ßn refresh token kh√¥ng"""
        if not self.expires_at:
            return False

        time_until_expiry = self.expires_at - datetime.now(VIETNAM_timezone)
        return time_until_expiry.total_seconds() <= (TOKEN_REFRESH_MARGIN_MINUTES * 60)

    def schedule_refresh(self):
        """L√™n l·ªãch refresh token"""
        if self.refresh_task and self.refresh_task.active():
            self.refresh_task.cancel()

        if not self.expires_at:
            return

        time_until_refresh = self.expires_at - datetime.now(VIETNAM_timezone) - timedelta(minutes=TOKEN_REFRESH_MARGIN_MINUTES)

        if time_until_refresh.total_seconds() > 0:
            self.refresh_task = reactor.callLater(
                time_until_refresh.total_seconds(),
                lambda: ctrader.refresh_access_token()
            )
            print(f"üìÖ ƒê√£ l√™n l·ªãch refresh token l√∫c: {(datetime.now(VIETNAM_timezone) + time_until_refresh).strftime('%Y-%m-%d %H:%M:%S UTC+7')}")
        else:
            # Token s·∫Øp h·∫øt h·∫°n, refresh ngay
            reactor.callLater(0, lambda: ctrader.refresh_access_token())

class CTraderClient:
    def __init__(self):
        self.client = Client(CTRADER_DEMO_HOST, CTRADER_DEMO_PORT, TcpProtocol)
        self.client.setConnectedCallback(self.on_Connected)
        self.client.setDisconnectedCallback(self.on_Disconnected)
        self.client.setMessageReceivedCallback(self.on_Message)
        self.symbol_ids = {}
        self.pending = []
        self.symbols_loaded_deferred = defer.Deferred() # Th√™m Deferred ƒë·ªÉ qu·∫£n l√Ω vi·ªác l·∫•y symbols
        self.subscribed_trendbars = {} # D√πng ƒë·ªÉ theo d√µi ƒëƒÉng k√Ω trendbar
        self.history_pending = set()   # Set l∆∞u tr·ªØ c√°c key ƒëang trong tr·∫°ng th√°i ch·ªù nh·∫≠n d·ªØ li·ªáu n·∫øn l·ªãch s·ª≠.
        self.token_manager = TokenManager()
        self.refresh_in_progress = False

    def start(self):
        """Starts the service"""
        self.client.startService()
    def on_Connected(self, client_instance):
        print("‚úÖ Connected to API")
        # Check token tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu g·ªçi chu·ªói x√°c th·ª±c sau Connected
        if self.token_manager.should_refresh_token() and self.token_manager.refresh_token:
            print("üîÑ Token s·∫Øp h·∫øt h·∫°n, th·ª±c hi·ªán refresh...")
            self.refresh_access_token()
        else:
            self._run_setup_sequence()
    def on_Disconnected(self, _, reason):
        print("‚ùå Disconnected from cTrader API")
        telegram.send("‚ùå Disconnected from cTrader API")
        reactor.stop()

    @inlineCallbacks
    def refresh_access_token(self):
        """Refresh access token using refresh token"""
        if self.refresh_in_progress:
            print("üîÑ Refresh ƒëang ƒë∆∞·ª£c th·ª±c hi·ªán...")
            return

        if not self.token_manager.refresh_token:
            print("‚ùå Kh√¥ng c√≥ refresh token ƒë·ªÉ th·ª±c hi·ªán refresh")
            telegram.send("‚ùå Kh√¥ng c√≥ refresh token - c·∫ßn c·∫≠p nh·∫≠t th·ªß c√¥ng")
            return

        try:
            self.refresh_in_progress = True
            print("üîÑ ƒêang refresh access token...")

            refresh_req = Protobuf.get('ProtoOARefreshTokenReq', 
                                     refreshToken=self.token_manager.refresh_token)
            yield self.client.send(refresh_req)

        except Exception as e:
            print(f"‚ùå L·ªói khi refresh token: {e}")
            telegram.send(f"‚ùå L·ªói refresh token: {e}")
            self.refresh_in_progress = False

    @inlineCallbacks
    def _run_setup_sequence(self):
        """
        Chu·ªói h√†nh ƒë·ªông tu·∫ßn t·ª± ƒë·ªÉ thi·∫øt l·∫≠p bot:
        1. App Autherize
        2. Acc Autherize
        3. Get symbols
        """
        try:
            # 1. App Autherize
            print("ƒêang x√°c th·ª±c App...")
            app_auth_req = Protobuf.get('ProtoOAApplicationAuthReq', clientId=CTRADER_CLIENT_ID, clientSecret=CTRADER_SECRET)
            yield self.client.send(app_auth_req)
            print("‚úÖ App auth successful.")

            # 2. Acc Autherize
            acc_auth_req = Protobuf.get('ProtoOAAccountAuthReq', ctidTraderAccountId=int(CTRADER_ACCOUNT_ID), accessToken=self.token_manager.access_token)
            yield self.client.send(acc_auth_req)
            print("‚úÖ Acc auth successful.")

            # 3. Get symbols
            print("ƒêang y√™u c·∫ßu danh s√°ch c·∫∑p ti·ªÅn...")
            symbols_list_req = Protobuf.get('ProtoOASymbolsListReq', ctidTraderAccountId=int(CTRADER_ACCOUNT_ID), includeArchivedSymbols=False)
            yield self.client.send(symbols_list_req)

            # ƒê·ª£i h√†m on_Message x·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ server
            yield self.symbols_loaded_deferred
            print("‚úÖ ƒê√£ t·∫£i xong danh s√°ch c√°c c·∫∑p ti·ªÅn.")

        except Exception as e:
            print(f"‚ùå L·ªói trong qu√° tr√¨nh thi·∫øt l·∫≠p ban ƒë·∫ßu: {e}")
            self.client.stopService()
            reactor.stop()

    def on_Message(self, _, message):
        """H√†m callback khi nh·∫≠n tin nh·∫Øn t·ª´ server."""

        # Gi·∫£i m√£ decode th√¥ t·ª´ server tr·∫£ v·ªÅ
        payload = Protobuf.extract(message)
        ptype = payload.payloadType

        # N·∫øu l√† d·∫°ng tin nh·∫Øn Error -> Print ra l·ªói t·ª´ API
        if ptype == Protobuf.get_type('ProtoOAErrorRes'):
            print(f"Server Error: Code {payload.errorCode}, Message: {payload.description}")
            # N·∫øu l·ªói li√™n quan ƒë·∫øn token
            if payload.errorCode in ["INVALID_TOKEN", "TOKEN_EXPIRED"]:
                telegram.send("‚ùå Token h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá!")
            return
        # X·ª≠ l√Ω ph·∫£n h·ªìi refresh token
        elif ptype == Protobuf.get_type('ProtoOARefreshTokenRes'):
            self.handle_refresh_token_response(payload)
            return

        # N·∫øu l√† d·∫°ng SymbolListRes, Khi received danh s√°ch symbols, g√°n v√†o self.symbol_ids v√† th√¥ng b√°o Deferred ƒë√£ ho√†n th√†nh
        if ptype == Protobuf.get_type('ProtoOASymbolsListRes'):
            for s in payload.symbol:
                if s.symbolName in PAIRS:
                    self.symbol_ids[s.symbolName] = s.symbolId
            if not self.symbols_loaded_deferred.called:
                 self.symbols_loaded_deferred.callback(None)

        # N·∫øu l√† type TrendbarsRes, g·ªçi h√†m x·ª≠ l√Ω 
        elif ptype == Protobuf.get_type('ProtoOAGetTrendbarsRes'):
            self.handle_trendbars(payload)

    def handle_refresh_token_response(self, payload):
        """X·ª≠ l√Ω ph·∫£n h·ªìi refresh token"""
        try:
            # C·∫≠p nh·∫≠t token m·ªõi
            self.token_manager.update_tokens(
                access_token=payload.accessToken,
                refresh_token=getattr(payload, 'refreshToken', None),
                expires_in_seconds=getattr(payload, 'expiresIn', None)
            )

            print("‚úÖ Refresh token th√†nh c√¥ng!")
            telegram.send("üîÑ Access token ƒë√£ ƒë∆∞·ª£c refresh th√†nh c√¥ng!")

            # Ti·∫øp t·ª•c v·ªõi setup n·∫øu ch∆∞a ho√†n th√†nh
            if not hasattr(self, 'symbols_loaded_deferred') or not self.symbols_loaded_deferred.called:
                self._run_setup_sequence()

        except Exception as e:
            print(f"‚ùå L·ªói x·ª≠ l√Ω refresh token response: {e}")
            telegram.send(f"‚ùå L·ªói x·ª≠ l√Ω refresh token: {e}")
        finally:
            self.refresh_in_progress = False

    def get_symbol_name_by_id(self, sid):
        for name, i in self.symbol_ids.items():
            if i == sid:
                return name
        return str(sid)

    def tf_from_period(self, period):
        for k, v in TIMEFRAME_MAP.items():
            if v == period:
                return k
        return str(period)

    @inlineCallbacks
    def subscribe(self, symbol, period):
        yield self.symbols_loaded_deferred # Ch·ªù cho ƒë·∫øn khi received Symbol List

        if symbol not in self.symbol_ids:
            print(f"‚ùå C·∫∑p ti·ªÅn {symbol} kh√¥ng t√¨m th·∫•y trong PAIRS.")
            return

        sid = self.symbol_ids[symbol]
        key = (sid, period)
        tf = self.tf_from_period(period)

        if key in self.subscribed_trendbars:
            print(f"‚úÖ ƒê√£ ƒëƒÉng k√Ω trendbar {symbol}/{tf}.")
            return

        # ƒê√°nh d·∫•u (symbol,tf) ƒëang ch·ªù d·ªØ li·ªáu l·ªãch s·ª≠ v√† ki·ªÉm tra tr·∫°ng th√°i subcribe
        self.history_pending.add(key)      # Add key v√†o set h√†ng ch·ªù nh·∫≠n d·ªØ li·ªáu l·ªãch s·ª≠
        self.subscribed_trendbars[key] = 0

        # 1. Y√™u c·∫ßu d·ªØ li·ªáu l·ªãch s·ª≠
        try:
            print(f"ƒêang y√™u c·∫ßu d·ªØ li·ªáu l·ªãch s·ª≠ cho {symbol}/{self.tf_from_period(period)}...")
            time_now = datetime.now(VIETNAM_timezone)
            period_seconds = PERIOD_SECONDS[period]
            from_ts = int((time_now - timedelta(seconds=period_seconds * MIN_BARS_BACK)).timestamp() * 1000)
            to_ts = int(time_now.timestamp() * 1000)

            hist_req = Protobuf.get('ProtoOAGetTrendbarsReq',
                                    ctidTraderAccountId=int(CTRADER_ACCOUNT_ID),
                                    symbolId=sid,
                                    period=period,
                                    fromTimestamp=from_ts,
                                    toTimestamp=to_ts,
                                    count=MIN_BARS_BACK)
            yield self.client.send(hist_req)
            print(f"‚úÖ ƒê√£ g·ª≠i y√™u c·∫ßu l·∫•y d·ªØ li·ªáu l·ªãch s·ª≠ cho {symbol}.")
        except Exception as e:
            print(f"L·ªói l·∫•y trendbar l·ªãch s·ª≠ {symbol}: {e}")
            self.history_pending.discard(key)
            self.subscribed_trendbars.pop(key, None)
            return

    @inlineCallbacks
    def unsubscribe(self, symbol, period):
        sid = self.symbol_ids.get(symbol)
        if not sid:
            return

        # D·ªçn d·∫πp tr·∫°ng th√°i l·ªãch s·ª≠ c√≤n ch·ªù (n·∫øu c√≥)
        self.history_pending.discard((sid, period))

    def handle_trendbars(self, payload):
        symbol = self.get_symbol_name_by_id(payload.symbolId)
        tf = self.tf_from_period(payload.period)
        key = (payload.symbolId, payload.period)

        # ƒê·∫øm s·ªë l∆∞·ª£ng bar trong payload
        bar_count = len(payload.trendbar)

        if key in self.history_pending:
            print(f"üìú {symbol}/{tf}: Nh·∫≠n {bar_count} history bars")

            # Build state b·∫±ng to√†n b·ªô history tr·ª´ n·∫øn cu·ªëi
            for tb in payload.trendbar[:-1]:
                process_trendbar(symbol, tf, tb, live=False)

            # üëâ Detect signal tr√™n n·∫øn l·ªãch s·ª≠ g·∫ßn hi·ªán t·∫°i nh·∫•t
            if payload.trendbar:
                last_tb = payload.trendbar[-1]
                process_trendbar(symbol, tf, last_tb, live=True)

            # C·∫≠p nh·∫≠t l·∫°i state
            self.history_pending.discard(key)
            self.subscribed_trendbars[key] = 1
            return

        # N·∫øu l·∫ßn ƒë·∫ßu subscribe -> coi nh∆∞ initial batch
        if key not in self.subscribed_trendbars:
            print(f"üìä {symbol}/{tf}: Nh·∫≠n {bar_count} initial bars")
            for tb in payload.trendbar[:-1]:
                process_trendbar(symbol, tf, tb, live=False)

            last_tb = payload.trendbar[-1]
            process_trendbar(symbol, tf, last_tb, live=True)

            self.subscribed_trendbars[key] = 1
            return

        # Ng∆∞·ª£c l·∫°i -> ƒë√¢y l√† live bars (bar l·ªãch s·ª≠ g·∫ßn nh·∫•t)
        print(f"üî¥ {symbol}/{tf}: Nh·∫≠n {bar_count} LIVE bars")
        for tb in payload.trendbar[:-1]:
            process_trendbar(symbol, tf, tb, live=False)

        last_tb = payload.trendbar[-1]
        process_trendbar(symbol, tf, last_tb, live=True)

def process_trendbar(symbol, tf, tb, live=True):
    key = (symbol, tf)
    data = market_data[key]
    if tb.utcTimestampInMinutes <= data["last_ts"]:
        return

    # C·∫≠p nh·∫≠t counter
    data["bar_count"] += 1
    if live:
        data["last_history_bars"] += 1
        bar_stats[key]["last_history_bars"] += 1
    else:
        data["history(-1)_bars"] += 1  
        bar_stats[key]["history(-1)_bars"] += 1

    bar_stats[key]["total_bars"] += 1

    # C·∫≠p nh·∫≠t th·ªùi gian
    if not data["first_bar_time"]:
        data["first_bar_time"] = tb.utcTimestampInMinutes
        bar_stats[key]["first_received"] = tb.utcTimestampInMinutes

    # Process price data
    scale = 1e5
    low = tb.low / scale
    close = (tb.low + tb.deltaClose) / scale
    high = (tb.low + tb.deltaHigh) / scale

    data["closes"].append(close) # Tr∆∞·ª£t set History ƒë·ªÉ +update trendbar, -oldest_trendbar
    data["highs"].append(high)
    data["lows"].append(low)

    # Calculate indicators
    closes = list(data["closes"])
    highs = list(data["highs"])
    lows = list(data["lows"])
    series = pd.Series(closes)
    ema_fast = series.ewm(span=EMA_FAST, adjust=False).mean()
    ema_slow = series.ewm(span=EMA_SLOW, adjust=False).mean()
    macd_line = ema_fast - ema_slow
    signal = macd_line.ewm(span=MACD_SIGNAL, adjust=False).mean()
    hist = macd_line - signal
    
    # ‚ú® CH·ªà L·∫§Y GI√Å TR·ªä HIST CU·ªêI C√ôNG - KH√îNG GHI ƒê√à H·∫æT!
    new_hist_value = hist.iloc[-1]       # Ch·ªâ l·∫•y gi√° tr·ªã hist m·ªõi nh·∫•t
    data["hist"].append(new_hist_value)  # Ch·ªâ th√™m 1 gi√° tr·ªã hist

    # Detect Signals
    signals = detect_signals(
        data["state"], symbol, tf, closes, highs, lows, list(data["hist"]), tb.utcTimestampInMinutes
    )  
    if live:
        for s in signals:
            telegram.send(s)
    data["last_ts"] = tb.utcTimestampInMinutes
    data["last_bar_time"] = tb.utcTimestampInMinutes  # TH√äM D√íNG N√ÄY

    # Print package milestone cho history bars (every package:1000 bars)
    total_bars = data["bar_count"]
    if not live and total_bars % 1000 == 0:
        percentage = (total_bars / MIN_BARS_BACK * 100) if total_bars > 0 else 0
        print(f"üìä {symbol}/{tf}: {total_bars}/{MIN_BARS_BACK} ({percentage:.1f}%) - History milestone")

    # Print periodic stats cho live bars (bar l·ªãch s·ª≠ g·∫ßn nh·∫•t) (every:10 bars)  
    if live and data["last_history_bars"] % 10 == 0:
        bar_time = datetime.fromtimestamp(tb.utcTimestampInMinutes * 60, VIETNAM_timezone)
        print(f"üî¥ {symbol}/{tf}: {data['last_history_bars']} New_history bars | Latest: {bar_time.strftime('%H:%M')}")

# TELEGRAM BOT =============================================
TELEGRAM_API = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}"
class TelegramBot:
    def __init__(self):
        self.offset = 0

    def send(self, text):
        d = treq.post(f"{TELEGRAM_API}/sendMessage", json={"chat_id": CHAT_ID, "text": text})
        # Th√™m h√†m x·ª≠ l√Ω l·ªói Telegram messenge v√† g·∫Øn n√≥ v√†o Deferred (d)
        def on_error(failure):
            print(f"‚ùå L·ªói khi g·ª≠i tin nh·∫Øn Telegram: {failure.getErrorMessage()}")
            return None
        d.addErrback(on_error)
        return d

    def poll(self):
        d = treq.get(f"{TELEGRAM_API}/getUpdates", params={"timeout":0, "offset": self.offset + 1})
        d.addCallback(treq.json_content)
        d.addCallback(self._handle_updates)
        d.addErrback(lambda _: None)

    def _handle_updates(self, data):
        for upd in data.get("result", []):
            self.offset = upd["update_id"]
            msg = upd.get("message", {})
            text = msg.get("text", "").strip()
            if not text:
                continue
            self.handle_command(text)

    def handle_command(self, text):
        if text.startswith("/help"):
            self.send(HELP_TEXT)
        elif text.startswith("/pairs"):
            pairs = "\n".join(f"{i+1}. {p}" for i,p in enumerate(PAIRS))
            self.send(f"üìä Pairs watching:\n{pairs}")
        elif text.startswith("/status"):
            self.send_status()
        elif text.startswith("/token status"):
            self.send_token_status()
        elif text.startswith("/refresh"):
            ctrader.refresh_access_token()
        elif text.startswith("/bars"):
            self.send_bar_stats()
        elif text.startswith("/reset_bars"):
            reset_bar_stats()
            self.send("üîÑ Bar statistics ƒë√£ ƒë∆∞·ª£c reset")
        elif text.startswith("/print_bars"):
            print_bar_stats()  # Print ra console
            self.send("üìä Bar statistics ƒë√£ ƒë∆∞·ª£c in ra console")
        elif text.startswith("/check"):
            missing = check_completed_bar_delays()
            if missing:
                msg = f"‚ùå {len(missing)} pairs missing completed bars:\n"
                for bar in missing[:8]:
                    msg += f"üî∏ {bar['key']}: missing {bar['missing_minutes']}m\n"
                    msg += f"   Last: {bar['last_received']} | Should: {bar['should_have']}\n"
            else:
                msg = "‚úÖ All pairs have latest completed bars"
            self.send(msg)
        elif text.startswith("/stop"):
            stop_scanning()
            self.send("üõë Scanning stopped")
        elif text.startswith("/scan"):
            parts = text.split(maxsplit=1)
            if len(parts) == 2:
                start_scanning(parts[1].strip())
            else:
                self.send("‚ö†Ô∏è Missing timeframe. Usage: /scan {timeframe}")
        else:
            self.send(f"Echo: {text}")

    def send_status(self):
        if active_timeframes:
            tfs = ", ".join(sorted(active_timeframes))
            self.send(f"‚úÖ Scanning active\nTimeframes: {tfs}\nPairs: {len(PAIRS)}")
        else:
            self.send("‚ö†Ô∏è Bot is idle. Use /scan to start.")

    def send_token_status(self):
        """G·ª≠i th√¥ng tin tr·∫°ng th√°i token"""
        tm = ctrader.token_manager
        if tm.expires_at:
            time_left = tm.expires_at - datetime.now(VIETNAM_timezone)
            days_left = time_left.days
            hours_left = time_left.seconds // 3600

            status = f"üîë TOKEN STATUS\n"
            status += f"‚è∞ Expires: {tm.expires_at.strftime('%Y-%m-%d %H:%M UTC')}\n"
            status += f"‚è≥ Time left: {days_left}d {hours_left}h\n"
            status += f"üîÑ Refresh token: {'‚úÖ' if tm.refresh_token else '‚ùå'}\n"
            status += f"üìÖ Auto refresh: {'‚úÖ' if tm.refresh_task and tm.refresh_task.active() else '‚ùå'}"
        else:
            status = "‚ö†Ô∏è Kh√¥ng c√≥ th√¥ng tin th·ªùi h·∫°n token"

        self.send(status)

    def send_bar_stats(self):
        """G·ª≠i th·ªëng k√™ bar qua Telegram - T·ªïng k·∫øt ng·∫Øn g·ªçn"""
        if not bar_stats:
            self.send("üìä Ch∆∞a c√≥ d·ªØ li·ªáu bar n√†o")
            return

        message = f"üìä BAR SUMMARY ({len(bar_stats)} symbols)\n"
        message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"

        # S·∫Øp x·∫øp theo t√™n symbol ƒë·ªÉ d·ªÖ ƒë·ªçc
        sorted_stats = sorted(bar_stats.items(), key=lambda x: (x[0][0], x[0][1]))

        for (symbol, tf), stats in sorted_stats:
            total = stats['total_bars']
            progress = f"{total}/{MIN_BARS_BACK}"
            percentage = (total / MIN_BARS_BACK * 100) if total > 0 else 0

            # Icon d·ª±a tr√™n t·ª∑ l·ªá ho√†n th√†nh
            if percentage >= 80:
                icon = "‚úÖ"
            elif percentage >= 50:
                icon = "üü°"
            elif percentage >= 20:
                icon = "üü†"
            else:
                icon = "üî¥"

            message += f"{icon} {symbol}/{tf}: {progress}\n"

        message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        message += "üí° /print_bars for detailed console view"

        self.send(message)

HELP_TEXT = (
"ü§ñ MACD Divergence Detection Bot \n"
"üìà T√≠nh nƒÉng ch√≠nh:\n"
"‚Ä¢ Ph√°t hi·ªán ph√¢n k·ª≥ MACD Classic & Miss Shoulder\n"
"‚Ä¢ Theo d√µi realtime t·ª´ IC Markets\n"
"‚Ä¢ H·ªó tr·ª£ 22 c·∫∑p ti·ªÅn ch√≠nh\n"
"‚Ä¢ ƒêa timeframe scanning\n"
"‚Ä¢ Auto refresh token\n"
"‚Ä¢ Bar counting & monitoring\n"
"üõ†Ô∏è Available Commands:\n"
"/help - H∆∞·ªõng d·∫´n & h·ªó tr·ª£\n"
"/status - Ki·ªÉm tra tr·∫°ng th√°i bot\n"
"/token - Ki·ªÉm tra tr·∫°ng th√°i token\n"
"/refresh - Th·ªß c√¥ng refresh token\n"
"/bars - Xem th·ªëng k√™ bar data\n"
"/print_bars - In chi ti·∫øt bar stats (console)\n"
"/reset_bars - Reset bar statistics\n"
"/missing - Ki·ªÉm tra pairs thi·∫øu update üÜï\n"
"/stop - Stop scanning\n"
"/pairs - Danh s√°ch c·∫∑p ti·ªÅn theo d√µi\n"
"/scan [timeframe] - Start scanning\n"
"üìä Scan Commands:\n"
"Presets:\n/scan 4T - 5m, 15m, 30m, 1h\n/scan 2t - 5m, 15m\n/scan 2T - 30m, 1h\n"
"Single timeframes:\n/scan 5m, /scan 15m, /scan 30m\n/scan 1h, /scan 4h, /scan 1d\n"
"üí° Tip: G·ª≠i tin nh·∫Øn th∆∞·ªùng ƒë·ªÉ test Echo feature!"
)

telegram = TelegramBot()
ctrader = CTraderClient()
loop = task.LoopingCall(telegram.poll)

@inlineCallbacks
def start_scanning(tf_text):
    """
    H√†m b·∫Øt ƒë·∫ßu Scanning, ƒë·∫£m b·∫£o bot ƒë√£ s·∫µn s√†ng tr∆∞·ªõc khi ƒëƒÉng k√Ω
    """
    print("üöÄ ƒêang kh·ªüi ƒë·ªông Scanning...")
    # Ch·ªù ·ªü ƒë√¢y cho ƒë·∫øn khi danh s√°ch symbols ƒë∆∞·ª£c t·∫£i xong
    yield ctrader.symbols_loaded_deferred

    # Sau khi ch·∫Øc ch·∫Øn ƒë√£ s·∫µn s√†ng, m·ªõi b·∫Øt ƒë·∫ßu ƒëƒÉng k√Ω
    tfs = PRESETS.get(tf_text, [tf_text])
    for tf in tfs:
        if tf not in TIMEFRAME_MAP:
            telegram.send(f"‚ùå Invalid timeframe {tf}")
            return
    for tf in tfs:
        active_timeframes.add(tf)
        for pair in PAIRS:
            yield ctrader.subscribe(pair, TIMEFRAME_MAP[tf]) # ƒê·∫£m b·∫£o m·ªói l·ªánh subscribe ƒë∆∞·ª£c g·ª≠i ƒëi tu·∫ßn t·ª±

    telegram.send(
        f"üöÄ SCAN STARTED\n‚è∞ Timeframe: {', '.join(tfs)}\nüìà Pairs: {len(PAIRS)} c·∫∑p ti·ªÅn\n"
        f"üîÑ Interval: {SCAN_INTERVAL_SEC} seconds\nüì° Source: IC Markets Demo\n"
        "üéØ Bot s·∫Ω th√¥ng b√°o khi c√≥ Divergence Signal!"
    )

def stop_scanning():
    for tf in list(active_timeframes):
        for pair in PAIRS:
            ctrader.unsubscribe(pair, TIMEFRAME_MAP[tf])
    active_timeframes.clear()
    market_data.clear()
    telegram.send("üõë Scanning stopped")
    print("\nüõë FINAL BAR STATISTICS BEFORE STOP:")
    print_bar_stats()

# KH·ªûI ƒê·ªòNG BOT
def main_startup_sequence():
    """
    Chu·ªói kh·ªüi ƒë·ªông ch√≠nh c·ªßa bot.
    """
    print("üöÄ ƒêang kh·ªüi ƒë·ªông MACD Divergence Bot...")

    # G·ª≠i tin nh·∫Øn ch√†o m·ª´ng ngay l·∫≠p t·ª©c
    telegram.send(
        "ü§ñ MACD Divergence Bot STARTED!\n"
        f"‚è∞ Time: {datetime.now(VIETNAM_timezone).strftime('%Y-%m-%d %H:%M:%S UTC+7')}\n"
        "üì° Data Source: IC Markets Demo\n"
        f"üìà Monitoring: {len(PAIRS)} currency pairs\n"
        f"üîß MACD: {EMA_FAST},{EMA_SLOW},{MACD_SIGNAL}\n\n"
        "üí° Type /help for instructions\n"
        "üöÄ Ready to scan for divergences!"
    )
    # Kh·ªüi ƒë·ªông client cTrader.
    ctrader.start()

if __name__ == '__main__':
    keep_alive()
    loop.start(1.0)
    # Ch·∫°y chu·ªói kh·ªüi ƒë·ªông ch√≠nh
    main_startup_sequence()
    # Kh·ªüi ƒë·ªông reactor ƒë·ªÉ ch·∫°y c√°c t√°c v·ª• b·∫•t ƒë·ªìng b·ªô
    reactor.run()
